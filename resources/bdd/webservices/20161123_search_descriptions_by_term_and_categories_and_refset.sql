-- Function: semantikos.search_descriptions_by_term_and_categories_and_refsets(character varying, bigint[])

-- DROP FUNCTION semantikos.search_descriptions_by_term_and_categories_and_refsets(character varying, bigint[]);

CREATE OR REPLACE FUNCTION semantikos.search_descriptions_by_term_and_categories_and_refsets(
    IN term_to_find character varying,
    IN categories bigint[],
		IN refsets bigint[])
  RETURNS TABLE(id bigint, description_id character varying, id_description_type bigint, pattern character varying, case_sensitive boolean, autogenerated boolean, is_published boolean, validity_until timestamp without time zone, id_concept bigint, id_user bigint, creation_date timestamp without time zone, is_modeled boolean) AS
$BODY$
BEGIN

  if categories is null then
    if refsets is null then
      RETURN QUERY select d.id, d.descid ,d.id_description_type, d.pattern, d.case_sensitive, d.autogenerated_name,  d.is_published,d.validity_until, c.id,d.id_user,d.creation_date, d.is_modeled
                 from semantikos.smtk_concept c
                   inner join semantikos.smtk_description d
                     on c.id=d.id_concept
                 where  lower(d.pattern)=term_to_find
                 order by d.id;
    else
      RETURN QUERY select d.id, d.descid ,d.id_description_type, d.pattern, d.case_sensitive, d.autogenerated_name,  d.is_published,d.validity_until, c.id,d.id_user,d.creation_date, d.is_modeled
                   from semantikos.smtk_concept c
                     inner join semantikos.smtk_description d
                       on c.id=d.id_concept
                     left join semantikos.smtk_refset_concept rc
                       on rc.id_concept=c.id
                   where  lower(d.pattern)=term_to_find and (rc.id_refset = any (refsets::int[]))
                   order by d.id;
    end if;
  else
    if refsets is null then
      RETURN QUERY select d.id, d.descid ,d.id_description_type, d.pattern, d.case_sensitive, d.autogenerated_name,  d.is_published,d.validity_until, c.id,d.id_user,d.creation_date, d.is_modeled
                 from semantikos.smtk_concept c
                   inner join semantikos.smtk_description d
                     on c.id=d.id_concept
                 where  lower(d.pattern)=term_to_find and (c.id_category = any (categories::int[]))
                 order by d.id;
      else
        RETURN QUERY select d.id, d.descid ,d.id_description_type, d.pattern, d.case_sensitive, d.autogenerated_name,  d.is_published,d.validity_until, c.id,d.id_user,d.creation_date, d.is_modeled
                     from semantikos.smtk_concept c
                       inner join semantikos.smtk_description d
                         on c.id=d.id_concept
                       left join semantikos.smtk_refset_concept rc
                        on rc.id_concept=c.id
                     where  lower(d.pattern)=term_to_find and (c.id_category = any (categories::int[])) and (rc.id_refset = any (refsets::int[]))
                     order by d.id;
      end if;
  end if;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION semantikos.search_descriptions_by_term_and_categories_and_refsets(character varying, bigint[], bigint[])
  OWNER TO postgres;
